{"version":3,"sources":["recorder.js"],"names":["passThrough","require","module","exports","recorded","settings","catalog","capture","request","callback","host","url","hostname","port","matchers","find","matcher","response","error","code","syscall","isDropped","refused","Error","errno","mode","recordResponseControl","save","saveError"],"mappings":";;;;;;;;AAAA,MAAMA,cAAcC,QAAQ,gBAAR,CAApB;;AAGAC,OAAOC,OAAP,GAAiB,SAASC,QAAT,CAAkBC,QAAlB,EAA4B;AAAA,QACnCC,OADmC,GACvBD,QADuB,CACnCC,OADmC;;AAE3C,QAAMC,UAAcP,YAAY,IAAZ,CAApB;;AAEA,SAAO,UAASQ,OAAT,EAAkBC,QAAlB,EAA4B;AACjC,QAAIC,OAAOF,QAAQG,GAAR,CAAYC,QAAvB;AACA,QAAIJ,QAAQG,GAAR,CAAYE,IAAZ,IAAoBL,QAAQG,GAAR,CAAYE,IAAZ,KAAqB,IAA7C,EACEH,OAAQ,GAAEA,IAAK,IAAGF,QAAQG,GAAR,CAAYE,IAAK,EAAnC;;AAEF;AACA,QAAI;AACF,YAAMC,WAAWR,QAAQS,IAAR,CAAaL,IAAb,CAAjB;AACA,UAAII,QAAJ;AAAA;AAAA;AAAA;;AAAA;AACE,0DAAoBA,QAApB,4GAA8B;AAAA,gBAArBE,OAAqB;;AAC5B,gBAAIC,WAAWD,QAAQR,OAAR,CAAf;AACA,gBAAIS,QAAJ,EAAc;AACZR,uBAAS,IAAT,EAAeQ,QAAf;AACA;AACD;AACF;AAPH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQD,KAVD,CAUE,OAAOC,KAAP,EAAc;AACdA,YAAMC,IAAN,GAAa,iBAAb;AACAD,YAAME,OAAN,GAAgB,SAAhB;AACAX,eAASS,KAAT;AACA;AACD;;AAED;AACA,QAAIb,SAASgB,SAAT,CAAmBb,QAAQG,GAAR,CAAYC,QAA/B,CAAJ,EAA8C;AAC5C,YAAMU,UAAU,IAAIC,KAAJ,CAAU,6BAAV,CAAhB;AACAD,cAAQH,IAAR,GAAeG,QAAQE,KAAR,GAAgB,cAA/B;AACAF,cAAQF,OAAR,GAAkB,SAAlB;AACAX,eAASa,OAAT;AACA;AACD;;AAED;AACA,QAAIjB,SAASoB,IAAT,KAAkB,QAAtB,EAAgC;AAC9BlB,cAAQC,OAAR,EAAiB,UAASU,KAAT,EAAgBD,QAAhB,EAA0B;AACzC,YAAIC,KAAJ,EACET,SAASS,KAAT,EADF,KAEK;AACH,cAAIb,SAASqB,qBAAT,IAAkCrB,SAASqB,qBAAT,CAA+BhB,IAA/B,CAAtC,EACE,IAAI,CAACL,SAASqB,qBAAT,CAA+BhB,IAA/B,EAAqCF,OAArC,EAA8CS,QAA9C,CAAL,EAA8D;AAC5D;AACAR,qBAAS,IAAT,EAAeQ,QAAf;AACA;AACD;;AAEHX,kBAAQqB,IAAR,CAAajB,IAAb,EAAmBF,OAAnB,EAA4BS,QAA5B,EAAsC,UAASW,SAAT,EAAoB;AACxDnB,qBAASmB,SAAT,EAAoBX,QAApB;AACD,WAFD;AAGD;AACF,OAfD;AAgBA;AACD;;AAED;AACAR;AACD,GAvDD;AAyDD,CA7DD","file":"recorder.js","sourcesContent":["const passThrough = require('./pass_through');\n\n\nmodule.exports = function recorded(settings) {\n  const { catalog } = settings;\n  const capture     = passThrough(true);\n\n  return function(request, callback) {\n    let host = request.url.hostname;\n    if (request.url.port && request.url.port !== '80')\n      host = `${host}:${request.url.port}`;\n\n    // Look for a matching response and replay it.\n    try {\n      const matchers = catalog.find(host);\n      if (matchers)\n        for (let matcher of matchers) {\n          let response = matcher(request);\n          if (response) {\n            callback(null, response);\n            return;\n          }\n        }\n    } catch (error) {\n      error.code = 'CORRUPT FIXTURE';\n      error.syscall = 'connect';\n      callback(error);\n      return;\n    }\n\n    // Do not record this host.\n    if (settings.isDropped(request.url.hostname)) {\n      const refused = new Error('Error: connect ECONNREFUSED');\n      refused.code = refused.errno = 'ECONNREFUSED';\n      refused.syscall = 'connect';\n      callback(refused);\n      return;\n    }\n\n    // In recording mode capture the response and store it.\n    if (settings.mode === 'record') {\n      capture(request, function(error, response) {\n        if (error)\n          callback(error);\n        else {\n          if (settings.recordResponseControl && settings.recordResponseControl[host])\n            if (!settings.recordResponseControl[host](request, response)) {\n              // don't save responses we don't like, eg. errors,\n              callback(null, response);\n              return;\n            }\n\n          catalog.save(host, request, response, function(saveError) {\n            callback(saveError, response);\n          });\n        };\n      });\n      return;\n    }\n\n    // Not in recording mode, pass control to the next proxy.\n    callback();\n  };\n\n};\n\n"]}