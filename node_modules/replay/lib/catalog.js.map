{"version":3,"sources":["catalog.js"],"names":["assert","require","debug","File","Path","Matcher","jsStringEscape","NEW_RESPONSE_FORMAT","OLD_RESPONSE_FORMAT","mkpathSync","pathname","existsSync","parent","dirname","mkdirSync","parseHeaders","filename","headerLines","only","headers","line","match","slice","name","value","key","toLowerCase","trim","replace","Array","isArray","push","parseRequest","request","requestHeaders","parseRegexp","rawRegexp","inRegexp","flags","RegExp","split","methodAndPath","method","path","regexp","test","body","url","parseResponse","response","statusLine","statusComponents","version","statusCode","statusMessage","rawHeaders","reduce","raw","header","trailers","rawTrailers","isResponseFormatNew","formattedStatus","parseInt","readAndInitialParseFile","buffer","readFileSync","parts","toString","length","parts0","Buffer","parts1","writeHeaders","file","item","write","regexps","module","exports","Catalog","constructor","settings","matchers","_basedir","resolve","getFixturesDir","setFixturesDir","dir","find","host","newMatchers","stat","statSync","isDirectory","files","readdirSync","filter","f","mapping","_read","fromMapping","save","callback","matcher","uid","Date","now","Math","floor","random","tmpfile","error","createWriteStream","encoding","toUpperCase","chunks","part","end","rename","undefined"],"mappings":"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","file":"catalog.js","sourcesContent":["const assert         = require('assert');\nconst debug          = require('./debug');\nconst File           = require('fs');\nconst Path           = require('path');\nconst Matcher        = require('./matcher');\nconst jsStringEscape = require('js-string-escape');\n\nconst NEW_RESPONSE_FORMAT = /HTTP\\/(\\d\\.\\d)\\s+(\\d{3})\\s*(.*)/;\nconst OLD_RESPONSE_FORMAT = /(\\d{3})\\s+HTTP\\/(\\d\\.\\d)/;\n\nfunction mkpathSync(pathname) {\n  if (File.existsSync(pathname))\n    return;\n  const parent = Path.dirname(pathname);\n  if (File.existsSync(parent))\n    File.mkdirSync(pathname);\n  else {\n    mkpathSync(parent);\n    File.mkdirSync(pathname);\n  }\n}\n\n\n// Parse headers from headerLines.  Optional argument `only` is an array of\n// regular expressions; only headers matching one of these expressions are\n// parsed.  Returns a object with name/value pairs.\nfunction parseHeaders(filename, headerLines, only = null) {\n  const headers = Object.create(null);\n  for (let line of headerLines) {\n    if (line === '')\n      continue;\n    let [name, value] = line.match(/^(.*?)\\:\\s+(.*)$/).slice(1);\n    if (only && !match(name, only))\n      continue;\n\n    const key  = (name || '').toLowerCase();\n    value = (value || '').trim().replace(/^\"(.*)\"$/, '$1');\n    if (Array.isArray(headers[key]))\n      headers[key].push(value);\n    else if (headers[key])\n      headers[key] = [headers[key], value];\n    else\n      headers[key] = value;\n  }\n  return headers;\n}\n\n\nfunction parseRequest(filename, request, requestHeaders) {\n  function parseRegexp(rawRegexp) {\n    const [ inRegexp, flags ] = rawRegexp.match(/^\\/(.+)\\/(i|m|g)?$/).slice(1);\n    return new RegExp(inRegexp, flags || '');\n  }\n\n  assert(request, `${filename} missing request section`);\n  const [ methodAndPath, ...headerLines ] = request.split(/\\n/);\n  let method;\n  let path;\n  let rawRegexp;\n  let regexp;\n  if (/\\sREGEXP\\s/.test(methodAndPath)) {\n    [ method, rawRegexp ]  = methodAndPath.split(' REGEXP ');\n    regexp = parseRegexp(rawRegexp);\n  } else\n    [ method, path ] = methodAndPath.split(/\\s/);\n  assert(method && (path || regexp), `${filename}: first line must be <method> <path>`);\n  assert(/^[a-zA-Z]+$/.test(method), `${filename}: method not valid`);\n\n  const headers = parseHeaders(filename, headerLines, requestHeaders);\n  let body      = headers.body;\n  delete headers.body;\n\n  if (body && /^REGEXP\\s+/.test(body)) {\n    rawRegexp = body.split(/REGEXP\\s+/)[1];\n    body = parseRegexp(rawRegexp);\n  }\n\n  const url = path || regexp;\n  return { url, method, headers, body };\n}\n\nfunction parseResponse(filename, response, body) {\n  if (response) {\n    const [ statusLine, ...headerLines ] = response.split(/\\n/);\n    const { version, statusCode, statusMessage } = statusComponents(statusLine)\n    const headers         = parseHeaders(filename, headerLines);\n    const rawHeaders      = headerLines.reduce(function(raw, header) {\n      const [name, value] = header.split(/:\\s+/);\n      raw.push(name);\n      raw.push(value);\n      return raw;\n    }, []);\n    return { statusCode, statusMessage, version, headers, rawHeaders, body, trailers: {}, rawTrailers: [] };\n  }\n}\n\nfunction statusComponents(statusLine) {\n  let response = {};\n  if ( isResponseFormatNew(statusLine) ) {\n    const formattedStatus = statusLine.match(NEW_RESPONSE_FORMAT);\n    response.version       = formattedStatus[1];\n    response.statusCode    = parseInt(formattedStatus[2], 10);\n    response.statusMessage = formattedStatus[3].trim();\n  } else {\n    const formattedStatus = statusLine.match(OLD_RESPONSE_FORMAT);\n    response.version       = formattedStatus[2];\n    response.statusCode    = parseInt(formattedStatus[0], 10);\n  }\n  return response;\n}\n\nfunction isResponseFormatNew(statusLine) {\n  return /^HTTP/.test(statusLine)\n}\n\nfunction readAndInitialParseFile(filename) {\n  const buffer  = File.readFileSync(filename);\n  const parts   = buffer.toString('utf8').split('\\n\\n');\n  if (parts.length > 2) {\n    const parts0  = new Buffer(parts[0], 'utf8');\n    const parts1  = new Buffer(parts[1], 'utf8');\n    const body    = buffer.slice(parts0.length + parts1.length + 4);\n    return [ parts[0], parts[1], body ];\n  } else\n    return [ parts[0], parts[1], '' ];\n}\n\n\n// Write headers to the File object.  Optional argument `only` is an array of\n// regular expressions; only headers matching one of these expressions are\n// written.\nfunction writeHeaders(file, headers, only = null) {\n  for (let name in headers) {\n    let value = headers[name];\n    if (only && !match(name, only))\n      continue;\n    if (Array.isArray(value))\n      for (let item of value)\n        file.write(`${name}: ${item}\\n`);\n    else\n      file.write(`${name}: ${value}\\n`);\n  }\n}\n\n\n// Returns true if header name matches one of the regular expressions.\nfunction match(name, regexps){\n  for (let regexp of regexps)\n    if (regexp.test(name))\n      return true;\n  return false;\n}\n\nmodule.exports = class Catalog {\n\n  constructor(settings) {\n    this.settings = settings;\n    // We use this to cache host/host:port mapped to array of matchers.\n    this.matchers = {};\n    this._basedir = Path.resolve('fixtures');\n  }\n\n  getFixturesDir() {\n    return this._basedir;\n  }\n\n  setFixturesDir(dir) {\n    this._basedir = Path.resolve(dir);\n    this.matchers = {};\n  }\n\n  find(host) {\n    // Return result from cache.\n    const matchers = this.matchers[host];\n    if (matchers)\n      return matchers;\n\n    // Start by looking for directory and loading each of the files.\n    // Look for host-port (windows friendly) or host:port (legacy)\n    let pathname = `${this.getFixturesDir()}/${host.replace(':', '-')}`;\n    if (!File.existsSync(pathname))\n      pathname = `${this.getFixturesDir()}/${host}`;\n    if (!File.existsSync(pathname))\n      return null;\n\n    const newMatchers = this.matchers[host] || [];\n    this.matchers[host] = newMatchers;\n\n    const stat = File.statSync(pathname);\n    if (stat.isDirectory()) {\n      let files = File.readdirSync(pathname);\n      // remove dot files from the list\n      files = files.filter(f => !/^\\./.test(f));\n      for (let file of files) {\n        let mapping = this._read(`${pathname}/${file}`);\n        newMatchers.push(Matcher.fromMapping(host, mapping));\n      }\n    } else {\n      const mapping = this._read(pathname);\n      newMatchers.push(Matcher.fromMapping(host, mapping));\n    }\n\n    return newMatchers;\n  }\n\n  save(host, request, response, callback) {\n    const matcher = Matcher.fromMapping(host, { request, response });\n    const matchers = this.matchers[host] || [];\n    matchers.push(matcher);\n    const requestHeaders = this.settings.headers;\n\n    const uid       = `${Date.now()}${Math.floor(Math.random() * 100000)}`;\n    const tmpfile   = `${this.getFixturesDir()}/node-replay.${uid}`;\n    const pathname  = `${this.getFixturesDir()}/${host.replace(':', '-')}`;\n\n    debug(`Creating ${pathname}`);\n    try {\n      mkpathSync(pathname);\n    } catch (error) {\n      setImmediate(function() {\n        callback(error);\n      });\n      return;\n    }\n\n    const filename = `${pathname}/${uid}`;\n    try {\n      const file = File.createWriteStream(tmpfile, { encoding: 'utf-8' });\n      file.write(`${request.method.toUpperCase()} ${request.url.path || '/'}\\n`);\n      writeHeaders(file, request.headers, requestHeaders);\n      if (request.body) {\n        let body = '';\n        for (let chunks of request.body)\n          body += chunks[0];\n        writeHeaders(file, { body: jsStringEscape(body) });\n      }\n      file.write('\\n');\n      // Response part\n      file.write(`HTTP/${response.version || '1.1'} ${response.statusCode || 200} ${response.statusMessage}\\n`);\n      writeHeaders(file, response.headers);\n      file.write('\\n');\n      for (let part of response.body)\n        file.write(part[0], part[1]);\n      file.end(function() {\n        File.rename(tmpfile, filename, callback);\n      });\n    } catch (error) {\n      callback(error);\n    }\n  }\n\n  _read(filename) {\n    const [request, response, part] = readAndInitialParseFile(filename);\n    const body = [[part, undefined]];\n    return {\n      request:  parseRequest(filename, request, this.settings.headers),\n      response: parseResponse(filename, response, body)\n    };\n  }\n\n};\n\n"]}